<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>mysql-index - My Docs</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "mysql-index";
    var mkdocs_page_input_path = "mysql-index.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> My Docs</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../Git-ComdLine-REST/">Git-ComdLine-REST</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../ADB%20%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3%E5%8F%8A%E7%94%A8%E6%B3%95%E5%A4%A7%E5%85%A8/">ADB 操作命令详解及用法大全</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../%E5%B7%B2%E4%B8%8A%E5%B2%B8%E5%AD%97%E8%8A%82%EF%BC%8C%E6%95%B4%E7%90%86%E4%B8%80%E6%B3%A2%E6%B5%8B%E5%BC%80%E9%9D%A2%E7%BB%8F_%E7%AC%94%E7%BB%8F%E9%9D%A2%E7%BB%8F_%E7%89%9B%E5%AE%A2%E7%BD%91/">已上岸字节，整理一波测开面经_笔经面经_牛客网</a>
                    </li>
                </ul>
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">mysql-index</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#_1">一、索引简介</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_2">索引的优缺点</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_3">何时使用索引</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_4">二、索引的数据结构</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_5">哈希索引</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#b">B 树索引</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_6">二叉搜索树</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#b_1">B+ 树</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_7">全文索引</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_8">空间数据索引</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_9">三、索引的类型</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#primary">主键索引（PRIMARY）</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#unique">唯一索引（UNIQUE）</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#index">普通索引（INDEX）</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#fulltext">全文索引（FULLTEXT）</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_10">联合索引</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_11">四、索引的策略</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_12">索引基本原则</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_13">独立的列</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_14">覆盖索引</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_15">使用索引来排序</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_16">前缀索引</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_17">最左前缀匹配原则</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#in">= 和 in 可以乱序</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_18">五、索引最佳实践</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_19">参考资料</a>
    </li>
    </ul>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">index</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../BenchmarkSQL5.0%20%E6%95%B0%E6%8D%AE%E5%BA%93%20TPC-C%20%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%20-%20%E7%91%BE%E7%86%99%E7%9A%84%E5%8D%9A%E5%AE%A2%20JL%20Blog/">BenchmarkSQL5.0 数据库 TPC-C 基准测试 - 瑾熙的博客 JL Blog</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../MIT6.824%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/">MIT6.824 分布式系统课程中文翻译</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E4%B8%8D%E7%9C%8B%E7%BB%9D%E5%AF%B9%E5%90%8E%E6%82%94_%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB_%E7%89%9B%E5%AE%A2%E7%BD%91/">史上最全的数据库面试题，不看绝对后悔_资源分享_牛客网</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../HTTP%20%E5%90%84%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7%E5%8F%8A%E5%8C%BA%E5%88%AB/">HTTP 各版本特性及区别</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../mysql-transaction/">mysql-transaction</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../%E6%B5%8B%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86%20-%20anliux%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD/">测试常见问题合集 - anliux - 博客园</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../%E4%B8%AA%E4%BA%BA%E5%90%90%E8%A1%80%E7%B3%BB%E5%88%97%20-%20%E6%80%BB%E7%BB%93%20MySQL/">个人吐血系列 - 总结 MySQL</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../%E4%BD%BF%E7%94%A8%20benchmarkSQL%20%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%20TPCC%20-%20konglingbin%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD/">使用 benchmarkSQL 测试数据库的 TPCC - konglingbin - 博客园</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">My Docs</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>mysql-index</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="db-tutorialmysql-indexmd">db-tutorial/mysql-index.md</h1>
<blockquote>
<p>索引是提高 MySQL 查询性能的一个重要途径，但过多的索引可能会导致过高的磁盘使用率以及过高的内存占用，从而影响应用程序的整体性能。应当尽量避免事后才想起添加索引，因为事后可能需要监控大量的 SQL 才能定位到问题所在，而且添加索引的时间肯定是远大于初始添加索引所需要的时间，可见索引的添加也是非常有技术含量的。</p>
<p>接下来将向你展示一系列创建高性能索引的策略，以及每条策略其背后的工作原理。但在此之前，先了解与索引相关的一些算法和数据结构，将有助于更好的理解后文的内容。</p>
</blockquote>
<p><a href="https://camo.githubusercontent.com/1fe57130bc0a8e8b4fa212713842af15d8a1618967836589ff6a67e401b7268a/687474703a2f2f64756e77752e746573742e757063646e2e6e65742f736e61702f32303230303731353137323030392e706e67"><img alt="" src="https://camo.githubusercontent.com/1fe57130bc0a8e8b4fa212713842af15d8a1618967836589ff6a67e401b7268a/687474703a2f2f64756e77752e746573742e757063646e2e6e65742f736e61702f32303230303731353137323030392e706e67" />
</a></p>
<ul>
<li><a href="#%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B">一、索引简介</a><ul>
<li><a href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">索引的优缺点</a></li>
<li><a href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95">何时使用索引</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">二、索引的数据结构</a><ul>
<li><a href="#%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95">哈希索引</a></li>
<li><a href="#b-%E6%A0%91%E7%B4%A2%E5%BC%95">B 树索引</a></li>
<li><a href="#%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95">全文索引</a></li>
<li><a href="#%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%B4%A2%E5%BC%95">空间数据索引</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E7%B4%A2%E5%BC%95%E7%9A%84%E7%B1%BB%E5%9E%8B">三、索引的类型</a></li>
<li><a href="#%E5%9B%9B%E7%B4%A2%E5%BC%95%E7%9A%84%E7%AD%96%E7%95%A5">四、索引的策略</a><ul>
<li><a href="#%E7%B4%A2%E5%BC%95%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99">索引基本原则</a></li>
<li><a href="#%E7%8B%AC%E7%AB%8B%E7%9A%84%E5%88%97">独立的列</a></li>
<li><a href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95">覆盖索引</a></li>
<li><a href="#%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95">前缀索引</a></li>
<li><a href="#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99">最左前缀匹配原则</a></li>
<li><a href="#-%E5%92%8C-in-%E5%8F%AF%E4%BB%A5%E4%B9%B1%E5%BA%8F">= 和 in 可以乱序</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">五、索引最佳实践</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h2 id="_1">一、索引简介</h2>
<p><strong><em>索引优化应该是查询性能优化的最有效手段</em></strong>。</p>
<h3 id="_2">索引的优缺点</h3>
<p>B+ 树索引，按照顺序存储数据，所以 Mysql 可以用来做 ORDER BY 和 GROUP BY 操作。因为数据是有序的，所以 B+ 树也就会将相关的列值都存储在一起。最后，因为索引中存储了实际的列值，所以某些查询只使用索引就能够完成全部查询。</p>
<p>✔ 索引的优点：</p>
<ul>
<li>索引大大减少了服务器需要扫描的数据量，从而加快检索速度。</li>
<li>支持行级锁的数据库，如 InnoDB 会在访问行的时候加锁。使用索引可以减少访问的行数，从而减少锁的竞争，提高并发。</li>
<li>索引可以帮助服务器避免排序和临时表。</li>
<li>索引可以将随机 I/O 变为顺序 I/O。</li>
<li>唯一索引可以确保每一行数据的唯一性，通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能。</li>
</ul>
<p>❌ 索引的缺点：</p>
<ul>
<li>创建和维护索引要耗费时间，这会随着数据量的增加而增加。</li>
<li><strong>索引需要占用额外的物理空间</strong>，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立组合索引那么需要的空间就会更大。</li>
<li>写操作（<code>INSERT</code>/<code>UPDATE</code>/<code>DELETE</code>）时很可能需要更新索引，导致数据库的写操作性能降低。</li>
</ul>
<h3 id="_3">何时使用索引</h3>
<blockquote>
<p>索引能够轻易将查询性能提升几个数量级。</p>
</blockquote>
<p>✔ 什么情况<strong>适用</strong>索引：</p>
<ul>
<li>表经常进行 <code>SELECT</code> 操作；</li>
<li>表的数据量比较大；</li>
<li>列名经常出现在 <code>WHERE</code> 或连接（<code>JOIN</code>）条件中</li>
</ul>
<p>❌ 什么情况<strong>不适用</strong>索引：</p>
<ul>
<li><strong>频繁写操作</strong>（ <code>INSERT</code>/<code>UPDATE</code>/<code>DELETE</code> ）- 需要更新索引空间；</li>
<li><strong>非常小的表</strong> - 对于非常小的表，大部分情况下简单的全表扫描更高效。</li>
<li>列名不经常出现在 <code>WHERE</code> 或连接（<code>JOIN</code>）条件中 - 索引就会经常不命中，没有意义，还增加空间开销。</li>
<li>对于特大型表，建立和使用索引的代价将随之增长。可以考虑使用分区技术或 Nosql。</li>
</ul>
<h2 id="_4">二、索引的数据结构</h2>
<h3 id="_5">哈希索引</h3>
<blockquote>
<p>Hash 索引只有精确匹配索引所有列的查询才有效。</p>
</blockquote>
<p>哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的值即 key，就可以找到其对应的值即 Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。</p>
<p>对于每一行数据，对所有的索引列计算一个 <code>hashcode</code>。哈希索引将所有的 <code>hashcode</code> 存储在索引中，同时在 Hash 表中保存指向每个数据行的指针。</p>
<p>哈希索引的<strong>优点</strong>：</p>
<ul>
<li>因为索引数据结构紧凑，所以<strong>查询速度非常快</strong>。</li>
</ul>
<p>哈希索引的<strong>缺点</strong>：</p>
<ul>
<li>哈希索引数据不是按照索引值顺序存储的，所以<strong>无法用于排序</strong>。</li>
<li>哈希索引<strong>不支持部分索引匹配查找</strong>。如，在数据列 (A,B) 上建立哈希索引，如果查询只有数据列 A，无法使用该索引。</li>
<li>哈希索引<strong>只支持等值比较查询</strong>，不支持任何范围查询，如 <code>WHERE price &gt; 100</code>。</li>
<li>哈希索引有<strong>可能出现哈希冲突</strong>，出现哈希冲突时，必须遍历链表中所有的行指针，逐行比较，直到找到符合条件的行。</li>
</ul>
<h3 id="b">B 树索引</h3>
<p>通常我们所说的索引是指<code>B-Tree</code>索引，它是目前关系型数据库中查找数据最为常用和有效的索引，大多数存储引擎都支持这种索引。使用<code>B-Tree</code>这个术语，是因为 MySQL 在<code>CREATE TABLE</code>或其它语句中使用了这个关键字，但实际上不同的存储引擎可能使用不同的数据结构，比如 InnoDB 就是使用的<code>B+Tree</code>。</p>
<p><code>B+Tree</code>中的 B 是指<code>balance</code>，意为平衡。需要注意的是，B + 树索引并不能找到一个给定键值的具体行，它找到的只是被查找数据行所在的页，接着数据库会把页读入到内存，再在内存中进行查找，最后得到要查找的数据。</p>
<h4 id="_6">二叉搜索树</h4>
<p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。其查询时间复杂度是 $$O(log(N))$$。</p>
<p>当然为了维持 $$O(log(N))$$ 的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是 $$O(log(N))$$。</p>
<p>随着数据库中数据的增加，索引本身大小随之增加，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘 I/O 消耗，相对于内存存取，I/O 存取的消耗要高几个数量级。可以想象一下一棵几百万节点的二叉树的深度是多少？如果将这么大深度的一颗二叉树放磁盘上，每读取一个节点，需要一次磁盘的 I/O 读取，整个查找的耗时显然是不能够接受的。那么如何减少查找过程中的 I/O 存取次数？</p>
<p>一种行之有效的解决方法是减少树的深度，将<strong>二叉树变为 N 叉树</strong>（多路搜索树），而 <strong>B+ 树就是一种多路搜索树</strong>。</p>
<h4 id="b_1">B+ 树</h4>
<p>B+ 树索引适用于<strong>全键值查找</strong>、<strong>键值范围查找</strong>和<strong>键前缀查找</strong>，其中键前缀查找只适用于最左前缀查找。</p>
<p>理解<code>B+Tree</code>时，只需要理解其最重要的两个特征即可：</p>
<ul>
<li>第一，所有的关键字（可以理解为数据）都存储在叶子节点，非叶子节点并不存储真正的数据，所有记录节点都是按键值大小顺序存放在同一层叶子节点上。</li>
<li>其次，所有的叶子节点由指针连接。如下图为简化了的<code>B+Tree</code>。</li>
</ul>
<p><a href="https://camo.githubusercontent.com/7ce8552c7cf966de604c6dfff3112165c6e83c5fc2d8862d4bd3a4502ff38829/687474703a2f2f64756e77752e746573742e757063646e2e6e65742f736e61702f32303230303330343233353432342e6a7067"><img alt="" src="https://camo.githubusercontent.com/7ce8552c7cf966de604c6dfff3112165c6e83c5fc2d8862d4bd3a4502ff38829/687474703a2f2f64756e77752e746573742e757063646e2e6e65742f736e61702f32303230303330343233353432342e6a7067" />
</a></p>
<p>根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p>
<ul>
<li><strong>聚簇索引（clustered）</strong>：又称为主键索引，其叶子节点存的是整行数据。因为无法同时把数据行存放在两个不同的地方，所以<strong>一个表只能有一个聚簇索引</strong>。<strong>InnoDB 的聚簇索引实际是在同一个结构中保存了 B 树的索引和数据行</strong>。</li>
<li>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为<strong>二级索引（secondary）</strong>。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于 249 个。</li>
</ul>
<p><strong>聚簇表示数据行和相邻的键值紧凑地存储在一起，因为数据紧凑，所以访问快</strong>。因为无法同时把数据行存放在两个不同的地方，所以<strong>一个表只能有一个聚簇索引</strong>。</p>
<p><strong>聚簇索引和非聚簇索引的查询有什么区别</strong></p>
<ul>
<li>如果语句是 <code>select * from T where ID=500</code>，即聚簇索引查询方式，则只需要搜索 ID 这棵 B+ 树；</li>
<li>如果语句是 <code>select * from T where k=5</code>，即非聚簇索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为<strong>回表</strong>。</li>
</ul>
<p>也就是说，<strong>基于非聚簇索引的查询需要多扫描一棵索引树</strong>。因此，我们在应用中应该尽量使用主键查询。</p>
<p><strong>显然，主键长度越小，非聚簇索引的叶子节点就越小，非聚簇索引占用的空间也就越小。</strong></p>
<p>自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。从性能和存储空间方面考量，自增主键往往是更合理的选择。有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的：</p>
<ul>
<li>只有一个索引；</li>
<li>该索引必须是唯一索引。</li>
</ul>
<p>由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。</p>
<p>这时候我们就要优先考虑上一段提到的 “尽量使用主键查询” 原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。</p>
<h3 id="_7">全文索引</h3>
<p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p>
<p>全文索引一般使用倒排索引实现，它记录着关键词到其所在文档的映射。</p>
<p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p>
<h3 id="_8">空间数据索引</h3>
<p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p>
<p>必须使用 GIS 相关的函数来维护数据。</p>
<h2 id="_9">三、索引的类型</h2>
<p>主流的关系型数据库一般都支持以下索引类型：</p>
<h3 id="primary">主键索引（<code>PRIMARY</code>）</h3>
<p>主键索引：一种特殊的唯一索引，不允许有空值。一个表只能有一个主键（在 InnoDB 中本质上即聚簇索引），一般是在建表的时候同时创建主键索引。</p>
<pre><code class="sql">CREATE TABLE `table` (
    `id` int(11) NOT NULL AUTO_INCREMENT,
    ...
    PRIMARY KEY (`id`)
)
</code></pre>

<h3 id="unique">唯一索引（<code>UNIQUE</code>）</h3>
<p>唯一索引：<strong>索引列的值必须唯一，但允许有空值</strong>。如果是组合索引，则列值的组合必须唯一。</p>
<pre><code class="sql">CREATE TABLE `table` (
    ...
    UNIQUE indexName (title(length))
)
</code></pre>

<h3 id="index">普通索引（<code>INDEX</code>）</h3>
<p>普通索引：最基本的索引，没有任何限制。</p>
<pre><code class="sql">CREATE TABLE `table` (
    ...
    INDEX index_name (title(length))
)
</code></pre>

<h3 id="fulltext">全文索引（<code>FULLTEXT</code>）</h3>
<p>全文索引：主要用来查找文本中的关键字，而不是直接与索引中的值相比较。</p>
<p>全文索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的 WHERE 语句的参数匹配。全文索引配合 <code>match against</code> 操作使用，而不是一般的 WHERE 语句加 LIKE。它可以在 <code>CREATE TABLE</code>，<code>ALTER TABLE</code> ，<code>CREATE INDEX</code> 使用，不过目前只有 <code>char</code>、<code>varchar</code>，<code>text</code> 列上可以创建全文索引。值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用 <code>CREATE INDEX</code> 创建全文索引，要比先为一张表建立全文索引然后再将数据写入的速度快很多。</p>
<pre><code class="sql">CREATE TABLE `table` (
    `content` text CHARACTER NULL,
    ...
    FULLTEXT (content)
)
</code></pre>

<h3 id="_10">联合索引</h3>
<p>组合索引：多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合。</p>
<pre><code class="sql">CREATE TABLE `table` (
    ...
    INDEX index_name (title(length), title(length), ...)
)
</code></pre>

<h2 id="_11">四、索引的策略</h2>
<p>假设有以下表：</p>
<pre><code class="sql">CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `city` varchar(16) NOT NULL,
  `name` varchar(16) NOT NULL,
  `age` int(11) NOT NULL,
  `addr` varchar(128) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `city` (`city`)
) ENGINE=InnoDB;
</code></pre>

<h3 id="_12">索引基本原则</h3>
<ul>
<li><strong>索引不是越多越好，不要为所有列都创建索引</strong>。要考虑到索引的维护代价、空间占用和查询时回表的代价。索引一定是按需创建的，并且要尽可能确保足够轻量。一旦创建了多字段的联合索引，我们要考虑尽可能利用索引本身完成数据查询，减少回表的成本。</li>
<li>要<strong>尽量避免冗余和重复索引</strong>。</li>
<li>要<strong>考虑删除未使用的索引</strong>。</li>
<li><strong>尽量的扩展索引，不要新建索引</strong>。</li>
<li><strong>频繁作为 <code>WHERE</code> 过滤条件的列应该考虑添加索引</strong>。</li>
</ul>
<h3 id="_13">独立的列</h3>
<p><strong>“独立的列” 是指索引列不能是表达式的一部分，也不能是函数的参数</strong>。</p>
<p><strong>对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。</strong></p>
<p>如果查询中的列不是独立的列，则数据库不会使用索引。</p>
<p>❌ 错误示例：</p>
<pre><code class="sql">SELECT actor_id FROM actor WHERE actor_id + 1 = 5;
SELECT ... WHERE TO_DAYS(current_date) - TO_DAYS(date_col) &lt;= 10;
</code></pre>

<h3 id="_14">覆盖索引</h3>
<p><strong>覆盖索引是指，索引上的信息足够满足查询请求，不需要再回到主键索引上去取数据。</strong></p>
<p>【示例】范围查询</p>
<pre><code class="sql">create table T (
ID int primary key,
k int NOT NULL DEFAULT 0,
s varchar(16) NOT NULL DEFAULT '',
index k(k))
engine=InnoDB;

insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg');

select * from T where k between 3 and 5
</code></pre>

<p>需要执行几次树的搜索操作，会扫描多少行？</p>
<ol>
<li>在 k 索引树上找到 k=3 的记录，取得 ID = 300；</li>
<li>再到 ID 索引树查到 ID=300 对应的 R3；</li>
<li>在 k 索引树取下一个值 k=5，取得 ID=500；</li>
<li>再回到 ID 索引树查到 ID=500 对应的 R4；</li>
<li>在 k 索引树取下一个值 k=6，不满足条件，循环结束。</li>
</ol>
<p>在这个过程中，<strong>回到主键索引树搜索的过程，我们称为回表</strong>。可以看到，这个查询过程读了 k 索引树的 3 条记录（步骤 1、3 和 5），回表了两次（步骤 2 和 4）。</p>
<p>如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。索引包含所有需要查询的字段的值，称为覆盖索引。</p>
<p><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</strong></p>
<h3 id="_15">使用索引来排序</h3>
<p>Mysql 有两种方式可以生成排序结果：通过排序操作；或者按索引顺序扫描。</p>
<p><strong>索引最好既满足排序，又用于查找行</strong>。这样，就可以通过命中覆盖索引直接将结果查出来，也就不再需要排序了。</p>
<p>这样整个查询语句的执行流程就变成了：</p>
<ol>
<li>从索引 (city,name,age) 找到第一个满足 city='杭州’条件的记录，取出其中的 city、name 和 age 这三个字段的值，作为结果集的一部分直接返回；</li>
<li>从索引 (city,name,age) 取下一个记录，同样取出这三个字段的值，作为结果集的一部分直接返回；</li>
<li>重复执行步骤 2，直到查到第 1000 条记录，或者是不满足 city='杭州’条件时循环结束。</li>
</ol>
<h3 id="_16">前缀索引</h3>
<p>有时候需要索引很长的字符列，这会让索引变得大且慢。</p>
<p>这时，可以使用前缀索引，即只索引开始的部分字符，这样可以<strong>大大节约索引空间</strong>，从而<strong>提高索引效率</strong>。但这样也<strong>会降低索引的选择性</strong>。对于 <code>BLOB</code>/<code>TEXT</code>/<code>VARCHAR</code> 这种文本类型的列，必须使用前缀索引，因为数据库往往不允许索引这些列的完整长度。</p>
<p><strong>索引的选择性</strong>是指：不重复的索引值和数据表记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，查询效率也越高。如果存在多条命中前缀索引的情况，就需要依次扫描，直到最终找到正确记录。</p>
<p><strong>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</strong></p>
<p>那么，如何确定前缀索引合适的长度呢？</p>
<p>可以使用下面这个语句，算出这个列上有多少个不同的值：</p>
<pre><code class="sql">select count(distinct email) as L from SUser;
</code></pre>

<p>然后，依次选取不同长度的前缀来看这个值，比如我们要看一下 4~7 个字节的前缀索引，可以用这个语句：</p>
<pre><code class="sql">select
  count(distinct left(email,4)）as L4,
  count(distinct left(email,5)）as L5,
  count(distinct left(email,6)）as L6,
  count(distinct left(email,7)）as L7,
from SUser;
</code></pre>

<p>当然，使用前缀索引很可能会损失区分度，所以你需要预先设定一个可以接受的损失比例，比如 5%。然后，在返回的 L4~L7 中，找出不小于 L * 95% 的值，假设这里 L6、L7 都满足，你就可以选择前缀长度为 6。</p>
<h3 id="_17">最左前缀匹配原则</h3>
<p>不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。</p>
<p>MySQL 会一直向右匹配直到遇到范围查询 <code>(&gt;,&lt;,BETWEEN,LIKE)</code> 就停止匹配。</p>
<ul>
<li>索引可以简单如一个列 (a)，也可以复杂如多个列 (a, b, c, d)，即<strong>联合索引</strong>。</li>
<li>如果是联合索引，那么 key 也由多个列组成，同时，索引只能用于查找 key 是否<strong>存在（相等）</strong>，遇到范围查询 (&gt;、&lt;、between、like 左匹配) 等就<strong>不能进一步匹配</strong>了，后续退化为线性查找。</li>
<li>因此，<strong>列的排列顺序决定了可命中索引的列数</strong>。</li>
</ul>
<p><strong>不要为每个列都创建独立索引</strong>。</p>
<p><strong>将选择性高的列或基数大的列优先排在多列索引最前列</strong>。但有时，也需要考虑 <code>WHERE</code> 子句中的排序、分组和范围条件等因素，这些因素也会对查询性能造成较大影响。</p>
<p>例如：<code>a = 1 and b = 2 and c &gt; 3 and d = 4</code>，如果建立（a,b,c,d）顺序的索引，d 是用不到索引的，如果建立 (a,b,d,c) 的索引则都可以用到，a,b,d 的顺序可以任意调整。</p>
<p>让选择性最强的索引列放在前面，索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，查询效率也越高。</p>
<p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p>
<pre><code class="sql">SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,
COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,
COUNT(*)
FROM payment;
</code></pre>

<pre><code class="batchfile">   staff_id_selectivity: 0.0001
customer_id_selectivity: 0.0373
               COUNT(*): 16049
</code></pre>

<h3 id="in">= 和 in 可以乱序</h3>
<p><strong>不需要考虑 <code>=</code>、<code>IN</code> 等的顺序</strong>，Mysql 会自动优化这些条件的顺序，以匹配尽可能多的索引列。</p>
<p>【示例】如有索引 (a, b, c, d)，查询条件 <code>c &gt; 3 and b = 2 and a = 1 and d &lt; 4</code> 与 <code>a = 1 and c &gt; 3 and b = 2 and d &lt; 4</code> 等顺序都是可以的，MySQL 会自动优化为 a = 1 and b = 2 and c &gt; 3 and d &lt; 4，依次命中 a、b、c、d。</p>
<h2 id="_18">五、索引最佳实践</h2>
<p>创建了索引，并非一定有效。比如不满足前缀索引、最左前缀匹配原则、查询条件涉及函数计算等情况都无法使用索引。此外，即使 SQL 本身符合索引的使用条件，MySQL 也会通过评估各种查询方式的代价，来决定是否走索引，以及走哪个索引。</p>
<p>因此，在尝试通过索引进行 SQL 性能优化的时候，务必通过执行计划（<code>EXPLAIN</code>）或实际的效果来确认索引是否能有效改善性能问题，否则增加了索引不但没解决性能问题，还增加了数据库增删改的负担。如果对 EXPLAIN 给出的执行计划有疑问的话，你还可以利用 <code>optimizer_trace</code> 查看详细的执行计划做进一步分析。</p>
<h2 id="_19">参考资料</h2>
<ul>
<li><a href="https://book.douban.com/subject/23008813/">《高性能 MySQL》</a></li>
<li><a href="https://juejin.im/post/5b55b842f265da0f9e589e79">数据库两大神器【索引和锁】</a></li>
<li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL 索引背后的数据结构及算法原理</a></li>
<li><a href="https://time.geekbang.org/column/intro/139">MySQL 实战 45 讲</a> 
    <a href="https://github.com/dunwu/db-tutorial/blob/master/docs/sql/mysql/mysql-index.md">https://github.com/dunwu/db-tutorial/blob/master/docs/sql/mysql/mysql-index.md</a></li>
</ul>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href=".." class="btn btn-neutral float-right" title="index">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../%E5%B7%B2%E4%B8%8A%E5%B2%B8%E5%AD%97%E8%8A%82%EF%BC%8C%E6%95%B4%E7%90%86%E4%B8%80%E6%B3%A2%E6%B5%8B%E5%BC%80%E9%9D%A2%E7%BB%8F_%E7%AC%94%E7%BB%8F%E9%9D%A2%E7%BB%8F_%E7%89%9B%E5%AE%A2%E7%BD%91/" class="btn btn-neutral" title="已上岸字节，整理一波测开面经_笔经面经_牛客网"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../%E5%B7%B2%E4%B8%8A%E5%B2%B8%E5%AD%97%E8%8A%82%EF%BC%8C%E6%95%B4%E7%90%86%E4%B8%80%E6%B3%A2%E6%B5%8B%E5%BC%80%E9%9D%A2%E7%BB%8F_%E7%AC%94%E7%BB%8F%E9%9D%A2%E7%BB%8F_%E7%89%9B%E5%AE%A2%E7%BD%91/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href=".." style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
